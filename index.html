<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Vehicle Dynamics - Fixed</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<style>
  body { margin:0; font-family:sans-serif; background:#eaeaea; overflow: hidden; }
  #container { display:flex; height:100vh; width: 100vw; }
  #ui { width:340px; padding:10px; background:#f5f5f5; border-right:1px solid #ccc; overflow-y:auto; flex-shrink: 0; box-shadow: 2px 0 5px rgba(0,0,0,0.1); z-index: 10; }
  #viewer { flex-grow:1; position:relative; background: #ccc; }
  
  h3 { margin:15px 0 5px 0; font-size:12px; border-bottom:1px solid #aaa; padding-bottom: 2px; text-transform: uppercase; letter-spacing: 0.5px; color: #444; }
  .grid2 { display:grid; grid-template-columns:1fr 1fr; gap:6px 10px; }
  label { font-size:11px; display:block; color: #666; }
  input[type="number"] { width:100%; padding:4px; font-size:11px; border:1px solid #ccc; border-radius: 3px; }
  .units { float:right; font-size:9px; color:#999; }
  
  button { width:100%; margin-top:10px; padding:8px; font-size:11px; cursor:pointer; background: #e0e0e0; border: 1px solid #bbb; border-radius: 3px; transition: background 0.2s; }
  button:hover { background: #d0d0d0; }

  #featureList div { background: #fff; padding: 4px; border: 1px solid #ddd; margin-top: 4px; font-size: 11px; display: flex; justify-content: space-between; align-items: center; }
  #featureList button { width: auto; margin: 0; padding: 2px 6px; font-size: 10px; height: auto; }
</style>
</head>

<body>
<div id="container">

<div id="ui">
  <h3>Box 1 (Chassis)</h3>
  <div class="grid2">
    <label>Length (Y) <span class="units">in</span><input id="box1_L" type="number" value="120"></label>
    <label>Width (X)  <span class="units">in</span><input id="box1_W" type="number" value="72"></label>
    <label>Height (Z) <span class="units">in</span><input id="box1_H" type="number" value="24"></label>
    <label>Weight     <span class="units">lb</span><input id="box1_Wt" type="number" value="2500"></label>
  </div>

  <h3>Box 2 (Cab/Cargo)</h3>
  <div class="grid2">
    <label>Length (Y) <span class="units">in</span><input id="box2_L" type="number" value="60"></label>
    <label>Width (X)  <span class="units">in</span><input id="box2_W" type="number" value="60"></label>
    <label>Height (Z) <span class="units">in</span><input id="box2_H" type="number" value="20"></label>
    <label>Weight     <span class="units">lb</span><input id="box2_Wt" type="number" value="800"></label>
    <label>Front Offset (Y) <span class="units">in</span><input id="box2_dY" type="number" value="0"></label>
  </div>

  <h3>Wheels</h3>
  <div class="grid2">
    <label>Diameter <span class="units">in</span><input id="wheel_D" type="number" value="32"></label>
    <label>Weight   <span class="units">lb</span><input id="wheel_Wt" type="number" value="120"></label>
    <label>Front Y  <span class="units">in</span><input id="wheel_Yf" type="number" value="-20"></label>
    <label>Rear Spacing <span class="units">in</span><input id="wheel_dYr" type="number" value="80"></label>
  </div>

  <h3>Suspension</h3>
  <div class="grid2">
    <label>Front K <span class="units">lb/in</span><input id="k_sf" type="number" value="300"></label>
    <label>Front C <span class="units">lb·s/in</span><input id="c_sf" type="number" value="25"></label>
    <label>Rear K <span class="units">lb/in</span><input id="k_sr" type="number" value="350"></label>
    <label>Rear C <span class="units">lb·s/in</span><input id="c_sr" type="number" value="30"></label>
  </div>

  <h3>Tires</h3>
  <div class="grid2">
    <label>Front K <span class="units">lb/in</span><input id="k_tf" type="number" value="1200"></label>
    <label>Rear K <span class="units">lb/in</span><input id="k_tr" type="number" value="1400"></label>
  </div>

  <h3>Simulation</h3>
  <div class="grid2">
    <label>Speed <span class="units">in/s</span><input id="veh_v" type="number" value="300"></label>
    <label>Gravity <span class="units">in/s²</span><input id="veh_g" type="number" value="386.1"></label>
  </div>
  
  <button id="updateBtn">Update Vehicle</button>

  <h3>Road Features</h3>
  <div class="grid2">
    <button id="addBumpBtn">Add Speed Bump</button>
    <button id="addHalfBumpBtn">Add 1/2 Bump</button>
  </div>
  <div id="featureList"></div>
</div>

<div id="viewer"></div>

</div>

<script type="module">
// FIX: Import directly from the full URL to avoid import map issues
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';

// --- GLOBALS ---
let scene, camera, renderer, controls;
let vehicleGroup, groundGroup;
let roadFeatures = [];
let nextFeatureId = 1;
let simTime = 0;
let massProps = null;
let wheelOffsets = null;

// Time Step
const dt = 1/120; 

// Physics State [z, phi, theta, dz, dphi, dtheta, ...zw, ...dzw]
const state = {
  z: 40, phi: 0, theta: 0,
  dz: 0, dphi: 0, dtheta: 0,
  zw: { FL:30, FR:30, RL:30, RR:30 },
  dzw: { FL:0, FR:0, RL:0, RR:0 }
};

// --- INITIALIZATION ---
init();
buildVehicle();
animate();

function init() {
  const container = document.getElementById('viewer');
  
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0xd0d0d0);
  scene.fog = new THREE.Fog(0xd0d0d0, 500, 4000);
  THREE.Object3D.DEFAULT_UP.set(0,0,1);

  camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 1, 10000);
  camera.position.set(300, -600, 400);

  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.shadowMap.enabled = true;
  container.appendChild(renderer.domElement);

  controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  
  // Lights
  scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.6));
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
  dirLight.position.set(100, -300, 500);
  dirLight.castShadow = true;
  dirLight.shadow.mapSize.width = 2048; 
  dirLight.shadow.mapSize.height = 2048;
  dirLight.shadow.camera.top = 500; dirLight.shadow.camera.bottom = -500;
  dirLight.shadow.camera.left = -500; dirLight.shadow.camera.right = 500;
  scene.add(dirLight);

  // Groups
  groundGroup = new THREE.Group();
  scene.add(groundGroup);
  vehicleGroup = new THREE.Group();
  scene.add(vehicleGroup); // This group will move with physics CG

  // Floor
  const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(10000, 10000), 
    new THREE.MeshStandardMaterial({ color: 0xbbbbbb, depthWrite: false })
  );
  floor.receiveShadow = true;
  groundGroup.add(floor);

  // Grid
  const grid = new THREE.GridHelper(10000, 100, 0x999999, 0xcccccc);
  grid.rotation.x = Math.PI/2;
  groundGroup.add(grid);

  window.addEventListener('resize', () => {
    camera.aspect = container.clientWidth / container.clientHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(container.clientWidth, container.clientHeight);
  });
}

function getVal(id) { return parseFloat(document.getElementById(id).value) || 0; }

// --- VEHICLE BUILDER ---
function buildVehicle() {
  vehicleGroup.clear();
  
  // 1. Gather Geometry Inputs
  const L1 = getVal('box1_L'), W1 = getVal('box1_W'), H1 = getVal('box1_H');
  const L2 = getVal('box2_L'), W2 = getVal('box2_W'), H2 = getVal('box2_H');
  const dY = getVal('box2_dY'); // Box 2 Front Offset
  const R  = getVal('wheel_D') / 2;
  
  const g = getVal('veh_g');
  const m1 = getVal('box1_Wt') / g;
  const m2 = getVal('box2_Wt') / g;
  const M = m1 + m2;

  // 2. Calculate Center of Gravity (CG)
  const c1 = { x:0, y: -L1/2,      z: H1/2 + R };
  const c2 = { x:0, y: dY - L2/2,  z: H1 + H2/2 + R };
  
  const CG = {
    x: (m1*c1.x + m2*c2.x) / M,
    y: (m1*c1.y + m2*c2.y) / M,
    z: (m1*c1.z + m2*c2.z) / M
  };

  // 3. Calculate Inertia (Parallel Axis Theorem)
  const Ixx1 = (m1/12)*(L1*L1 + H1*H1);
  const Ixx2 = (m2/12)*(L2*L2 + H2*H2);
  const dy1 = c1.y-CG.y, dz1 = c1.z-CG.z;
  const dy2 = c2.y-CG.y, dz2 = c2.z-CG.z;
  const Ixx = (Ixx1 + m1*(dy1*dy1 + dz1*dz1)) + (Ixx2 + m2*(dy2*dy2 + dz2*dz2));

  const Iyy1 = (m1/12)*(W1*W1 + H1*H1);
  const Iyy2 = (m2/12)*(W2*W2 + H2*H2);
  const dx1 = c1.x-CG.x; // 0
  const dx2 = c2.x-CG.x; // 0
  const Iyy = (Iyy1 + m1*(dx1*dx1 + dz1*dz1)) + (Iyy2 + m2*(dx2*dx2 + dz2*dz2));

  massProps = { M, CG, Ixx, Iyy };

  // 4. Build Visuals (Centered around CG)
  // Box 1
  const b1 = new THREE.Mesh(new THREE.BoxGeometry(W1, L1, H1), new THREE.MeshStandardMaterial({color: 0x5577aa}));
  b1.position.set(c1.x - CG.x, c1.y - CG.y, c1.z - CG.z);
  b1.castShadow = true;
  vehicleGroup.add(b1);

  // Box 2
  const b2 = new THREE.Mesh(new THREE.BoxGeometry(W2, L2, H2), new THREE.MeshStandardMaterial({color: 0x88aabb}));
  b2.position.set(c2.x - CG.x, c2.y - CG.y, c2.z - CG.z);
  b2.castShadow = true;
  vehicleGroup.add(b2);

  // Wheels
  const wheelGeo = new THREE.CylinderGeometry(R, R, W1*0.2, 24); // Width proportional to car
  wheelGeo.rotateZ(Math.PI/2);
  const wheelMat = new THREE.MeshStandardMaterial({color: 0x222222});

  const yF = getVal('wheel_Yf');
  const yR = yF - getVal('wheel_dYr');
  const xW = W1/2; // Approx track width

  const wheels = [
    {n:'FL', x: -xW, y: yF}, {n:'FR', x: xW, y: yF},
    {n:'RL', x: -xW, y: yR}, {n:'RR', x: xW, y: yR}
  ];

  wheelOffsets = wheels.map(w => ({
    name: w.n,
    x: w.x - CG.x,
    y: w.y - CG.y
  }));

  wheels.forEach(w => {
    const mesh = new THREE.Mesh(wheelGeo, wheelMat);
    mesh.name = "W_" + w.n;
    // Initial local pos relative to CG
    mesh.position.set(w.x - CG.x, w.y - CG.y, R - CG.z); 
    mesh.castShadow = true;
    vehicleGroup.add(mesh);
  });

  // Reset Physics State
  state.z = CG.z + 20; // Drop from height
  state.phi = 0; state.theta = 0;
  state.dz = 0; state.dphi = 0; state.dtheta = 0;
  state.zw.FL = state.zw.FR = state.zw.RL = state.zw.RR = CG.z;
  simTime = 0;
}

document.getElementById('updateBtn').onclick = buildVehicle;

// --- ROAD FEATURES ---
// Helper: Add visual mesh for bump
function addFeatureMesh(geom, color, x, y) {
  const mesh = new THREE.Mesh(geom, new THREE.MeshStandardMaterial({color}));
  mesh.position.set(x, y, 0);
  mesh.receiveShadow = true;
  groundGroup.add(mesh);
  return mesh;
}

document.getElementById('addBumpBtn').onclick = () => {
  const h = 3, w = 24, y = 100 + roadFeatures.length*100; // Auto-space
  addSpeedBump(h, w, y);
};

document.getElementById('addHalfBumpBtn').onclick = () => {
  const h = 3, w = 24, y = 100 + roadFeatures.length*100;
  addHalfSpeedBump(h, w, y, 'left');
};

function addSpeedBump(h, w, y) {
  const W = getVal('box1_W') * 4; 
  const r = w/2;
  const shape = new THREE.Shape();
  shape.moveTo(-r,0); shape.absarc(0,0,r,0,Math.PI,false); shape.lineTo(r,0);
  const geom = new THREE.ExtrudeGeometry(shape, {depth:W, bevelEnabled:false});
  geom.rotateX(Math.PI/2); geom.rotateZ(Math.PI/2);
  const mesh = addFeatureMesh(geom, 0x888888, 0, y);
  roadFeatures.push({id: nextFeatureId++, type:'bump', params:{h,w,y}, mesh});
  refreshFeatures();
}

function addHalfSpeedBump(h, w, y, side) {
  const W = getVal('box1_W') * 1.5;
  const r = w/2;
  const shape = new THREE.Shape();
  shape.moveTo(-r,0); shape.absarc(0,0,r,0,Math.PI,false); shape.lineTo(r,0);
  const geom = new THREE.ExtrudeGeometry(shape, {depth:W, bevelEnabled:false});
  geom.rotateX(Math.PI/2); geom.rotateZ(Math.PI/2);
  const xOff = (side==='left' ? -1 : 1) * (W/2 + 10);
  const mesh = addFeatureMesh(geom, 0x777777, xOff, y);
  roadFeatures.push({id: nextFeatureId++, type:'half-bump', params:{h,w,y,side}, mesh});
  refreshFeatures();
}

function refreshFeatures() {
  const div = document.getElementById('featureList');
  div.innerHTML = roadFeatures.map((f,i) => 
    `<div>
       <span>${f.type} @ ${f.params.y.toFixed(0)}</span>
       <button onclick="window.delFeat(${i})">x</button>
     </div>`
  ).join('');
}

window.delFeat = (i) => {
  groundGroup.remove(roadFeatures[i].mesh);
  roadFeatures.splice(i,1);
  refreshFeatures();
};

function getRoadZ(x, y) {
  let z = 0;
  for(let f of roadFeatures) {
    const dy = y - f.params.y;
    const r = f.params.w/2;
    if(Math.abs(dy) < r) {
      if(f.type === 'half-bump') {
        if(f.params.side === 'left' && x > 0) continue;
        if(f.params.side === 'right' && x < 0) continue;
      }
      z = Math.max(z, f.params.h * Math.sqrt(1 - (dy*dy)/(r*r)));
    }
  }
  return z;
}

// --- PHYSICS ENGINE (RK4) ---
function getDerivatives(t, s) {
  if(!massProps || !wheelOffsets) return Array(14).fill(0);

  const z=s[0], phi=s[1], theta=s[2];
  const dz=s[3], dphi=s[4], dtheta=s[5];
  
  const v = getVal('veh_v');
  const g = getVal('veh_g');
  const wm = getVal('wheel_Wt') / g;
  
  let FzBody=0, Tx=0, Ty=0;
  const ddzw = [0,0,0,0];

  const names = ['FL','FR','RL','RR'];
  const R = getVal('wheel_D')/2;

  names.forEach((n, i) => {
    const wOff = wheelOffsets[i];
    const zw = s[6+i];
    const dzw = s[10+i];

    // Suspension
    // Body height at wheel corner
    const zb = z - phi*wOff.x + theta*wOff.y;
    const dzb = dz - dphi*wOff.x + dtheta*wOff.y;
    
    const isFront = n.startsWith('F');
    const k_s = isFront ? getVal('k_sf') : getVal('k_sr');
    const c_s = isFront ? getVal('c_sf') : getVal('c_sr');
    
    // Model: Force = k * (FreeLen - (zb - zw)). 
    const freeLen = 25; 
    const comp = freeLen - (zb - zw);
    const dcomp = -(dzb - dzw);
    const F_susp = Math.max(0, k_s * comp + c_s * dcomp);
    
    // Sum Body Forces
    FzBody += F_susp;
    Tx += F_susp * wOff.y; // Pitch
    Ty -= F_susp * wOff.x; // Roll

    // Tire
    const roadY = wOff.y + (v * t);
    const roadX = wOff.x; 
    // Absolute X for road lookup (Wheel Offset from CG + CG X position)
    // Assuming we drive straight down Y, CG X is constant at massProps.CG.x relative to road center 0?
    // Actually, road is centered at x=0. 
    // wOff.x is wheel relative to CG. 
    // If CG is at x=0 (symmetric), absX = wOff.x.
    // If CG is offset, we need to account for that.
    const absX = wOff.x + massProps.CG.x;
    
    const roadZ = getRoadZ(absX, roadY);
    
    const pen = roadZ - (zw - R);
    const k_t = isFront ? getVal('k_tf') : getVal('k_tr');
    const F_tire = (pen > 0) ? k_t * pen : 0;

    // Wheel Accel
    ddzw[i] = (F_tire - F_susp - wm*g) / wm;
  });

  const ddz = (FzBody - massProps.M*g) / massProps.M;
  const ddphi = Ty / massProps.Iyy;
  const ddtheta = Tx / massProps.Ixx;
  
  return [
    dz, dphi, dtheta,
    ddz, ddphi, ddtheta,
    s[10], s[11], s[12], s[13],
    ddzw[0], ddzw[1], ddzw[2], ddzw[3]
  ];
}

function stepRK4(dt) {
  const s = [
    state.z, state.phi, state.theta,
    state.dz, state.dphi, state.dtheta,
    state.zw.FL, state.zw.FR, state.zw.RL, state.zw.RR,
    state.dzw.FL, state.dzw.FR, state.dzw.RL, state.dzw.RR
  ];
  const t = simTime;
  
  const k1 = getDerivatives(t, s);
  const s2 = s.map((v,i) => v + k1[i]*dt*0.5);
  const k2 = getDerivatives(t+dt*0.5, s2);
  const s3 = s.map((v,i) => v + k2[i]*dt*0.5);
  const k3 = getDerivatives(t+dt*0.5, s3);
  const s4 = s.map((v,i) => v + k3[i]*dt);
  const k4 = getDerivatives(t+dt, s4);
  
  const fin = s.map((v,i) => v + (dt/6)*(k1[i] + 2*k2[i] + 2*k3[i] + k4[i]));
  
  state.z=fin[0]; state.phi=fin[1]; state.theta=fin[2];
  state.dz=fin[3]; state.dphi=fin[4]; state.dtheta=fin[5];
  state.zw.FL=fin[6]; state.zw.FR=fin[7]; state.zw.RL=fin[8]; state.zw.RR=fin[9];
  state.dzw.FL=fin[10]; state.dzw.FR=fin[11]; state.dzw.RL=fin[12]; state.dzw.RR=fin[13];
  
  simTime += dt;
}

// --- ANIMATION ---
function animate() {
  requestAnimationFrame(animate);
  if(massProps) stepRK4(dt);
  
  // Sync Visuals
  vehicleGroup.position.set(0, 0, state.z);
  vehicleGroup.rotation.set(state.theta, state.phi, 0);

  // Move Ground
  const dist = getVal('veh_v') * simTime;
  groundGroup.position.y = -dist;

  // Move Wheels (Locally)
  if(wheelOffsets) {
    const names = ['FL','FR','RL','RR'];
    const R = getVal('wheel_D')/2;
    names.forEach(n => {
      const mesh = vehicleGroup.getObjectByName("W_"+n);
      if(mesh) {
        // mesh is child of vehicleGroup (which is at state.z)
        // mesh.position.z needs to be (zw - state.z) + offsets
        // BUT mesh was created at (R - CG.z). 
        // We want absolute Z of center to be zw.
        // So local z = zw - state.z.
        mesh.position.z = state.zw[n] - state.z;
      }
    });
  }

  renderer.render(scene, camera);
}
</script>
</body>
</html>



























