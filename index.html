<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

let scene, camera, renderer, controls;
let vehicleGroup, groundGroup, looseBox3Mesh;
let roadFeatures = [];
let nextFeatureId = 1;
let simTime = 0;
let massProps = null;
let wheelOffsets = null;
let isRunning = false;
let chartInstance = null;
const maxDataPoints = 200; 
let chartUpdateCounter = 0;
const dt = 1/120; 

const state = {
  z: 40, phi: 0, theta: 0,
  dz: 0, dphi: 0, dtheta: 0,
  zw: { FL:30, FR:30, RL:30, RR:30 },
  dzw: { FL:0, FR:0, RL:0, RR:0 },
  ddz: 0 // Storage for graphing
};

const box3State = {
  x: 0, y: 0, z: 0,
  dx: 0, dy: 0, dz: 0,
  az: 0,
  isOffBed: false
};

init();
initChart();
buildVehicle();
setupAutoUpdate();
animate();

function init() {
  const container = document.getElementById('viewer');
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0xd0d0d0);
  scene.fog = new THREE.Fog(0xd0d0d0, 500, 4000);
  THREE.Object3D.DEFAULT_UP.set(0,0,1);
  camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 1, 10000);
  camera.position.set(400, -800, 500);
  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(container.clientWidth, container.clientHeight);
  renderer.shadowMap.enabled = true;
  container.appendChild(renderer.domElement);
  controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  
  scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.6));
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
  dirLight.position.set(100, -300, 500);
  dirLight.castShadow = true;
  dirLight.shadow.mapSize.width = 2048; 
  dirLight.shadow.mapSize.height = 2048;
  dirLight.shadow.camera.top = 500; dirLight.shadow.camera.bottom = -500;
  dirLight.shadow.camera.left = -500; dirLight.shadow.camera.right = 500;
  scene.add(dirLight);
  
  groundGroup = new THREE.Group();
  scene.add(groundGroup);
  vehicleGroup = new THREE.Group();
  scene.add(vehicleGroup);
  
  const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(10000, 10000), 
    new THREE.MeshStandardMaterial({ color: 0xbbbbbb, depthWrite: false })
  );
  floor.receiveShadow = true;
  groundGroup.add(floor);
  
  const grid = new THREE.GridHelper(10000, 100, 0x999999, 0xcccccc);
  grid.rotation.x = Math.PI/2;
  groundGroup.add(grid);
  
  window.addEventListener('resize', () => {
    const w = container.clientWidth;
    const h = container.clientHeight;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
  });
}

function initChart() {
  const ctx = document.getElementById('accelChart').getContext('2d');
  const commonOptions = { pointRadius: 0, borderWidth: 1.5, tension: 0.2 };
  chartInstance = new Chart(ctx, {
    type: 'line',
    data: {
      labels: [],
      datasets: [
        { label: 'CG', borderColor: 'black', ...commonOptions, borderWidth: 3 },
        { label: 'FL', borderColor: 'red', ...commonOptions },
        { label: 'FR', borderColor: 'blue', ...commonOptions },
        { label: 'RL', borderColor: 'orange', ...commonOptions },
        { label: 'RR', borderColor: 'green', ...commonOptions },
        { label: 'User', borderColor: 'purple', ...commonOptions, borderDash: [5, 5], borderWidth: 2 },
        { label: 'Box3 (Abs)', borderColor: 'magenta', ...commonOptions, borderDash: [3, 3], borderWidth: 2 }
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      animation: false,
      plugins: {
        title: { display: true, text: 'Vertical Acceleration (G)' },
        legend: { position: 'right', labels: { boxWidth: 10 } }
      },
      scales: {
        x: { display: false },
        y: { title: { display: true, text: 'G-Force' }, suggestedMin: -2, suggestedMax: 2 }
      }
    }
  });
}

function updateChartLogic(t) {
  chartUpdateCounter++;
  if(chartUpdateCounter < 5) return;
  chartUpdateCounter = 0;
  
  const g = getVal('veh_g'); 
  const toG = (val) => val / g;
  
  const aCG = toG(state.ddz);
  const aBox3 = toG(box3State.az);
  
  // Recalculate chassis corners for graph
  // Note: These calculations assume box1 is centered relative to CG laterally (x)
  // and longitudinally positioned based on c1.y.
  // c1.y was -L1/2 relative to origin, then we subtracted CG.y.
  // So box1 center relative to CG is (-L1/2 - CG.y).
  const L = getVal('box1_L');
  const W = getVal('box1_W');
  const c1y = (-L/2) - massProps.CG.y; 
  // CG x is massProps.CG.x (absolute). Center of box 1 relative to CG is (0 - CG.x).
  const c1x = -massProps.CG.x;

  const getCornerAcc = (dx, dy) => {
    // dx, dy are offset from box 1 center
    const x = c1x + dx;
    const y = c1y + dy;
    return toG(state.ddz - state.ddphi * x + state.ddtheta * y);
  };
  
  const aFL = getCornerAcc(-W/2, L/2);
  const aFR = getCornerAcc(W/2, L/2);
  const aRL = getCornerAcc(-W/2, -L/2);
  const aRR = getCornerAcc(W/2, -L/2);
  
  const ux = getVal('user_X') - massProps.CG.x;
  const uy = getVal('user_Y') - massProps.CG.y;
  const aUser = toG(state.ddz - state.ddphi * ux + state.ddtheta * uy);
  
  const lbl = t.toFixed(2);
  const chart = chartInstance;
  chart.data.labels.push(lbl);
  
  chart.data.datasets[0].data.push(aCG);
  chart.data.datasets[1].data.push(aFL);
  chart.data.datasets[2].data.push(aFR);
  chart.data.datasets[3].data.push(aRL);
  chart.data.datasets[4].data.push(aRR);
  chart.data.datasets[5].data.push(aUser);
  chart.data.datasets[6].data.push(aBox3);
  
  if(chart.data.labels.length > maxDataPoints) {
    chart.data.labels.shift();
    chart.data.datasets.forEach(ds => ds.data.shift());
  }
  chart.options.plugins.title.text = `Vertical Acceleration (G) - Time: ${t.toFixed(2)}s`;
  chart.update();
}

function packState(s) {
  return [
    s.z, s.phi, s.theta,
    s.dz, s.dphi, s.dtheta,
    s.zw.FL, s.zw.FR, s.zw.RL, s.zw.RR,
    s.dzw.FL, s.dzw.FR, s.dzw.RL, s.dzw.RR
  ];
}

function getVal(id) { return parseFloat(document.getElementById(id).value) || 0; }
function setVal(id, val) { document.getElementById(id).value = val; }

function setupAutoUpdate() {
  const inputs = document.querySelectorAll('.auto-update-group input');
  inputs.forEach(input => {
    input.addEventListener('input', () => { buildVehicle(true); });
  });
}

document.getElementById('solveBtn').onclick = () => { isRunning = true; };
document.getElementById('stopBtn').onclick = () => { isRunning = false; };
document.getElementById('updateBtn').onclick = () => buildVehicle(false);

function buildVehicle(isAutoUpdate = false) {
  if(!isAutoUpdate) {
    isRunning = false;
    simTime = 0;
    if(chartInstance) {
      chartInstance.data.labels = [];
      chartInstance.data.datasets.forEach(ds => ds.data = []);
      chartInstance.update();
    }
  }
  vehicleGroup.clear();
  
  const L1 = getVal('box1_L'), W1 = getVal('box1_W'), H1 = getVal('box1_H');
  const L2 = getVal('box2_L'), W2 = getVal('box2_W'), H2 = getVal('box2_H');
  const L3 = getVal('box3_L'), W3 = getVal('box3_W'), H3 = getVal('box3_H');
  const dY = getVal('box2_dY'); 
  const R  = getVal('wheel_D') / 2;
  const g = getVal('veh_g');
  const m1 = getVal('box1_Wt') / g;
  const m2 = getVal('box2_Wt') / g;
  const M = m1 + m2;
  
  const c1 = { x:0, y: -L1/2, z: H1/2 + R };
  const c2 = { x:0, y: dY - L2/2, z: H1 + H2/2 + R };
  const CG = {
    x: (m1*c1.x + m2*c2.x) / M,
    y: (m1*c1.y + m2*c2.y) / M,
    z: (m1*c1.z + m2*c2.z) / M
  };
  
  const Ixx = (m1/12)*(L1*L1 + H1*H1) + m1*((c1.y-CG.y)**2 + (c1.z-CG.z)**2) + 
              (m2/12)*(L2*L2 + H2*H2) + m2*((c2.y-CG.y)**2 + (c2.z-CG.z)**2);
  const Iyy = (m1/12)*(W1*W1 + H1*H1) + m1*((c1.x-CG.x)**2 + (c1.z-CG.z)**2) + 
              (m2/12)*(W2*W2 + H2*H2) + m2*((c2.x-CG.x)**2 + (c2.z-CG.z)**2);
  massProps = { M, CG, Ixx, Iyy };
  
  const b1 = new THREE.Mesh(new THREE.BoxGeometry(W1, L1, H1), new THREE.MeshStandardMaterial({color: 0x5577aa}));
  b1.position.set(c1.x - CG.x, c1.y - CG.y, c1.z - CG.z);
  b1.castShadow = true;
  vehicleGroup.add(b1);
  
  const b2 = new THREE.Mesh(new THREE.BoxGeometry(W2, L2, H2), new THREE.MeshStandardMaterial({color: 0x88aabb}));
  b2.position.set(c2.x - CG.x, c2.y - CG.y, c2.z - CG.z);
  b2.castShadow = true;
  vehicleGroup.add(b2);
  
  looseBox3Mesh = new THREE.Mesh(new THREE.BoxGeometry(W3, L3, H3), new THREE.MeshStandardMaterial({color: 0xff4444}));
  looseBox3Mesh.castShadow = true;
  vehicleGroup.add(looseBox3Mesh); 
  
  const wheelGeo = new THREE.CylinderGeometry(R, R, W1*0.2, 24);
  wheelGeo.rotateZ(Math.PI/2);
  const wheelMat = new THREE.MeshStandardMaterial({color: 0x222222});
  const yF = getVal('wheel_Yf');
  const yR = yF - getVal('wheel_dYr');
  const xW = W1/2; 
  const wheels = [ {n:'FL', x: -xW, y: yF}, {n:'FR', x: xW, y: yF}, {n:'RL', x: -xW, y: yR}, {n:'RR', x: xW, y: yR} ];
  wheelOffsets = wheels.map(w => ({ name: w.n, x: w.x - CG.x, y: w.y - CG.y }));
  wheels.forEach(w => {
    const mesh = new THREE.Mesh(wheelGeo, wheelMat);
    mesh.name = "W_" + w.n;
    mesh.position.set(w.x - CG.x, w.y - CG.y, R - CG.z); 
    mesh.castShadow = true;
    vehicleGroup.add(mesh);
  });
  
  if(!isAutoUpdate || simTime === 0) {
    state.z = CG.z + 10; 
    state.phi = 0; state.theta = 0;
    state.dz = 0; state.dphi = 0; state.dtheta = 0;
    state.zw.FL = state.zw.FR = state.zw.RL = state.zw.RR = CG.z;
    
    // Init Box 3 slightly above bed
    const bedHeight = (c1.z - CG.z) + H1/2;
    box3State.x = getVal('box3_X0');
    box3State.y = getVal('box3_Y0');
    box3State.z = bedHeight + H3/2 + 2; 
    box3State.dx = 0; box3State.dy = 0; box3State.dz = 0;
    box3State.isOffBed = false;
  }
}

function addFeatureMesh(geom, color, x, y) {
  const mesh = new THREE.Mesh(geom, new THREE.MeshStandardMaterial({color}));
  mesh.position.set(x, y, 0);
  mesh.receiveShadow = true;
  groundGroup.add(mesh);
  return mesh;
}

document.getElementById('addFeatureBtn').onclick = () => {
  const type = document.getElementById('feat_Type').value;
  const h = getVal('feat_H');
  const w = getVal('feat_W'); 
  const y = getVal('feat_Y');
  if (type === 'full') addSpeedBump(h, w, y);
  else if (type === 'half_L') addHalfSpeedBump(h, w, y, 'left');
  else if (type === 'half_R') addHalfSpeedBump(h, w, y, 'right');
  else if (type === 'rough') addRoughPatch(h, w, y);
  setVal('feat_Y', y + (type==='rough' ? w + 50 : 100));
};

function addSpeedBump(h, w, y) {
  const W = getVal('box1_W') * 3; 
  const geom = new THREE.ExtrudeGeometry(new THREE.Shape().moveTo(-w/2,0).absarc(0,0,w/2,0,Math.PI,false).lineTo(w/2,0), {depth:W, bevelEnabled:false});
  geom.translate(0, 0, -W/2); geom.rotateX(Math.PI/2); geom.rotateZ(Math.PI/2);
  const mesh = addFeatureMesh(geom, 0x888888, 0, y);
  roadFeatures.push({id: nextFeatureId++, type:'bump', params:{h,w,y}, mesh});
  refreshFeatures();
}

function addHalfSpeedBump(h, w, y, side) {
  const carWidth = getVal('box1_W');
  const geom = new THREE.ExtrudeGeometry(new THREE.Shape().moveTo(-w/2,0).absarc(0,0,w/2,0,Math.PI,false).lineTo(w/2,0), {depth:carWidth*0.4, bevelEnabled:false});
  geom.translate(0, 0, -carWidth*0.2); geom.rotateX(Math.PI/2); geom.rotateZ(Math.PI/2);
  const xOff = (side==='left' ? -carWidth/2 : carWidth/2);
  const mesh = addFeatureMesh(geom, 0x777777, xOff, y);
  roadFeatures.push({id: nextFeatureId++, type:'half-bump', params:{h,w,y,side}, mesh});
  refreshFeatures();
}

function addRoughPatch(h, w, y) {
  const carWidth = getVal('box1_W');
  const geom = new THREE.PlaneGeometry(carWidth * 3, w, 20, Math.max(5, Math.floor(w/10)));
  const pos = geom.attributes.position;
  for(let i=0; i<pos.count; i++) pos.setZ(i, pos.getZ(i) + (Math.random()-0.5)*2.0);
  geom.computeVertexNormals();
  const mesh = new THREE.Mesh(geom, new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 1.0, flatShading: true }));
  mesh.position.set(0, y, 0.5);
  groundGroup.add(mesh);
  roadFeatures.push({id: nextFeatureId++, type:'rough', params:{h,w,y}, mesh});
  refreshFeatures();
}

function refreshFeatures() {
  const div = document.getElementById('featureList');
  div.innerHTML = roadFeatures.map((f,i) => {
    let desc = f.type;
    if(f.type==='half-bump') desc = f.params.side==='left' ? '½L' : '½R';
    if(f.type==='rough') desc = 'Rough';
    return `<div><span><b>${desc}</b> @${f.params.y.toFixed(0)}</span><button onclick="window.delFeat(${i})">x</button></div>`;
  }).join('');
}
window.delFeat = (i) => { groundGroup.remove(roadFeatures[i].mesh); roadFeatures.splice(i,1); refreshFeatures(); };

function getRoadZ(x, y) {
  let z = 0;
  for(let f of roadFeatures) {
    if(f.type === 'rough') {
      if (y >= (f.params.y - f.params.w/2) && y <= (f.params.y + f.params.w/2)) {
        z = f.params.h * (0.5*Math.sin(0.1*y)*Math.sin(0.1*x) + 0.3*Math.sin(0.3*y+1.2) + 0.2*Math.sin(0.5*(x+y)));
      }
      continue;
    }
    const dy = y - f.params.y;
    const r = f.params.w/2;
    if(Math.abs(dy) < r) {
      if(f.type === 'half-bump' && ((f.params.side === 'left' && x > 0) || (f.params.side === 'right' && x < 0))) continue;
      z = Math.max(z, f.params.h * Math.sqrt(1 - (dy*dy)/(r*r)));
    }
  }
  return z;
}

// --- SUB-STEPPED BOX PHYSICS (FIXED GRAVITY & GROUND) ---
function stepBox3(dt, vehAccel) {
  const substeps = 10;
  const subDt = dt / substeps;
  
  const g = getVal('veh_g');
  const m3 = getVal('box3_Wt') / g;
  const H3 = getVal('box3_H');
  const H1 = getVal('box1_H');
  const W1 = getVal('box1_W');
  const L1 = getVal('box1_L');
  const R_wheel = getVal('wheel_D') / 2;
  
  const bedLocalZ = (H1/2 + R_wheel) - massProps.CG.z + H1/2; 
  
  // Calculate Mass-Adaptive parameters
  const targetSquish = 0.5; 
  const k = (m3 * g) / targetSquish;
  
  const zeta_comp = 0.5;
  const zeta_reb = 0.01; // Low damping on rebound for bounce
  const c_comp = 2 * zeta_comp * Math.sqrt(k * m3);
  const c_reb = 2 * zeta_reb * Math.sqrt(k * m3);
  
  // Rotation Matrices components for World->Local Gravity transformation
  // Gravity in World is (0,0,-g). 
  // We need components in the Local Frame (Vehicle Frame).
  // Vehicle frame is rotated by theta (Y) and phi (X).
  // Local Gravity = InverseRotation * WorldGravity
  // For small angles this is approx: Gx = g*sin(theta), Gy = -g*sin(phi), Gz = -g*cos(phi)cos(theta)
  // We use exact trig here.
  const sinP = Math.sin(state.phi), cosP = Math.cos(state.phi);
  const sinT = Math.sin(state.theta), cosT = Math.cos(state.theta);
  
  // Force of Gravity in Local Frame:
  // G_local_x =  g * sin(theta)
  // G_local_y = -g * sin(phi) * cos(theta)
  // G_local_z = -g * cos(phi) * cos(theta)
  const Fg_x = m3 * g * sinT;
  const Fg_y = m3 * g * (-sinP * cosT);
  const Fg_z = m3 * g * (-cosP * cosT);

  for(let i=0; i<substeps; i++) {
    // 1. Bed Boundary Check
    const onBedX = Math.abs(box3State.x) < W1/2;
    // Box 1 center in vehicle frame (relative to CG):
    const b1cy = (-L1/2) - massProps.CG.y;
    const minY = b1cy - L1/2;
    const maxY = b1cy + L1/2;
    const onBedY = box3State.y > minY && box3State.y < maxY;
    
    const isOverBed = onBedX && onBedY;
    
    const boxBottom = box3State.z - H3/2;
    const pen = bedLocalZ - boxBottom;
    
    let Fz = 0, Fx = 0, Fy = 0;
    
    // BED CONTACT
    if(pen > 0 && isOverBed) {
      const F_spring = k * pen;
      const c = (box3State.dz < 0) ? c_comp : c_reb;
      const F_damp = c * (-box3State.dz);
      Fz = Math.max(0, F_spring + F_damp);
      
      const mu = getVal('box3_Fric');
      const maxFriction = mu * Fz;
      const vx = box3State.dx; 
      const vy = box3State.dy;
      const v_rel = Math.sqrt(vx*vx + vy*vy);
      
      if(v_rel > 0.1) {
        Fx = -maxFriction * (vx / v_rel);
        Fy = -maxFriction * (vy / v_rel);
      } else {
        Fx = -vx * 500;
        Fy = -vy * 500;
      }
    }
    
    // GROUND CHECK (Precise World Coords)
    // Box bottom local point: (x, y, z - H3/2)
    // Rotate to World Z component:
    const lz = box3State.z - H3/2;
    // Z_w_rel = -sinT*x + sinP*cosT*y + cosP*cosT*lz
    const rotZ = -sinT*box3State.x + sinP*cosT*box3State.y + cosP*cosT*lz;
    const worldBottomZ = state.z + rotZ;
    const groundHeight = 0; // Flat floor at 0
    
    if (worldBottomZ < groundHeight) {
       // Ground Contact
       const penGround = groundHeight - worldBottomZ;
       
       // Force direction? Up in World Frame (0,0,1).
       // We need to apply this force in Local Frame.
       // Local Up vector = InverseRotation * (0,0,1)
       // This is essentially the same vector direction as we used for gravity derivation but positive.
       // Up_local_x = -sinT
       // Up_local_y = sinP * cosT
       // Up_local_z = cosP * cosT
       
       const k_g = k; // same stiffness as bed
       const F_g_mag = k_g * penGround; // Magnitude
       
       // Add components to local forces
       Fx += F_g_mag * (-sinT);
       Fy += F_g_mag * (sinP * cosT);
       Fz += F_g_mag * (cosP * cosT);
       
       // Friction against ground (Absolute velocity damping)
       // Approx: Just damp local velocity heavily to stop it sliding on ground?
       // Ideally we calculate absolute velocity at contact point.
       // For this demo, simple damping:
       Fx -= box3State.dx * 10.0;
       Fy -= box3State.dy * 10.0;
       // Also add 'ground drag' to simulate absolute friction leaving the box behind
       const v_car = getVal('veh_v');
       // If box is on ground, it should stop moving in world.
       // V_world ~ V_car + V_local.
       // We want V_world -> 0. So V_local -> -V_car.
       // We apply force proportional to (V_local - (-V_car)) = V_local + V_car
       const dragCoeff = 20.0;
       Fy -= (box3State.dy + v_car) * dragCoeff; 
    }

    // Inertial Forces (Fictitious forces from vehicle accel)
    const F_inertial_z = -m3 * vehAccel.ddz; 
    // Ideally we'd add F_inertial_y for accel/braking, but assume const speed for now.
    
    // Sum Forces
    const F_total_x = Fx + Fg_x;
    const F_total_y = Fy + Fg_y;
    const F_total_z = Fz + Fg_z + F_inertial_z;
    
    const ax = F_total_x / m3;
    const ay = F_total_y / m3;
    const az = F_total_z / m3;
    
    box3State.dx += ax * subDt;
    box3State.dy += ay * subDt;
    box3State.dz += az * subDt;
    
    box3State.x += box3State.dx * subDt;
    box3State.y += box3State.dy * subDt;
    box3State.z += box3State.dz * subDt;
    
    box3State.az = az + vehAccel.ddz;
  }
}

function getDerivatives(t, s_arr) {
  if(!massProps || !wheelOffsets) return Array(14).fill(0);
  const z=s_arr[0], phi=s_arr[1], theta=s_arr[2];
  const dz=s_arr[3], dphi=s_arr[4], dtheta=s_arr[5];
  const v = getVal('veh_v');
  const g = getVal('veh_g');
  const wm = getVal('wheel_Wt') / g;
  let FzBody=0, Tx=0, Ty=0;
  const ddzw = [0,0,0,0];
  const names = ['FL','FR','RL','RR'];
  const R = getVal('wheel_D')/2;
  
  names.forEach((n, i) => {
    const wOff = wheelOffsets[i];
    const zw = s_arr[6+i];
    const zb = z - phi*wOff.x + theta*wOff.y;
    const dzb = dz - dphi*wOff.x + dtheta*wOff.y;
    const k_s = n.startsWith('F') ? getVal('k_sf') : getVal('k_sr');
    const c_s = n.startsWith('F') ? getVal('c_sf') : getVal('c_sr');
    const freeLen = 25; 
    const comp = freeLen - (zb - zw);
    const dcomp = -(dzb - s_arr[10+i]);
    const F_susp = Math.max(0, k_s * comp + c_s * dcomp);
    FzBody += F_susp;
    Tx += F_susp * wOff.y;
    Ty -= F_susp * wOff.x;
    
    const roadY = wOff.y + (v * t);
    const absX = wOff.x + massProps.CG.x;
    const roadZ = getRoadZ(absX, roadY);
    const pen = roadZ - (zw - R);
    const k_t = n.startsWith('F') ? getVal('k_tf') : getVal('k_tr');
    const F_tire = (pen > 0) ? k_t * pen : 0;
    ddzw[i] = (F_tire - F_susp - wm*g) / wm;
  });
  
  const ddz = (FzBody - massProps.M*g) / massProps.M;
  const ddphi = Ty / massProps.Iyy;
  const ddtheta = Tx / massProps.Ixx;
  
  return [ dz, dphi, dtheta, ddz, ddphi, ddtheta, s_arr[10], s_arr[11], s_arr[12], s_arr[13], ddzw[0], ddzw[1], ddzw[2], ddzw[3] ];
}

function stepRK4(dt) {
  const s = packState(state);
  const t = simTime;
  const k1 = getDerivatives(t, s);
  const s2 = s.map((v,i) => v + k1[i]*dt*0.5);
  const k2 = getDerivatives(t+dt*0.5, s2);
  const s3 = s.map((v,i) => v + k2[i]*dt*0.5);
  const k3 = getDerivatives(t+dt*0.5, s3);
  const s4 = s.map((v,i) => v + k3[i]*dt);
  const k4 = getDerivatives(t+dt, s4);
  const fin = s.map((v,i) => v + (dt/6)*(k1[i] + 2*k2[i] + 2*k3[i] + k4[i]));
  
  state.z=fin[0]; state.phi=fin[1]; state.theta=fin[2];
  state.dz=fin[3]; state.dphi=fin[4]; state.dtheta=fin[5];
  state.zw.FL=fin[6]; state.zw.FR=fin[7]; state.zw.RL=fin[8]; state.zw.RR=fin[9];
  state.dzw.FL=fin[10]; state.dzw.FR=fin[11]; state.dzw.RL=fin[12]; state.dzw.RR=fin[13];
  
  const vehAccel = { ddz: k1[3], ddphi: k1[4], ddtheta: k1[5] };
  stepBox3(dt, vehAccel);
  
  state.ddz = vehAccel.ddz; 
  state.ddphi = vehAccel.ddphi;
  state.ddtheta = vehAccel.ddtheta;
  
  simTime += dt;
}

function animate() {
  requestAnimationFrame(animate);
  if(isRunning && massProps) {
    const timeScale = getVal('time_scale');
    stepRK4(dt * timeScale);
    updateChartLogic(simTime);
  }
  
  vehicleGroup.position.set(0, 0, state.z);
  vehicleGroup.rotation.set(state.theta, state.phi, 0);
  const dist = getVal('veh_v') * simTime;
  groundGroup.position.y = -dist;
  
  if(wheelOffsets) {
    const names = ['FL','FR','RL','RR'];
    names.forEach(n => {
      const mesh = vehicleGroup.getObjectByName("W_"+n);
      if(mesh) mesh.position.z = state.zw[n] - state.z;
    });
  }
  
  if(looseBox3Mesh) {
    looseBox3Mesh.position.set(box3State.x, box3State.y, box3State.z);
  }
  
  renderer.render(scene, camera);
}
</script>



























